diff --git a/build/config/rust.gni b/build/config/rust.gni
index b05e37015287ac01f9d57b8d0276bd32e354ba96..3961a5f3c9fa35379411964aee60822ff2607060 100644
--- a/build/config/rust.gni
+++ b/build/config/rust.gni
@@ -19,15 +19,9 @@ declare_args() {
   # should not be removed.
   # TODO(crbug.com/1386212): Mac
   # TODO(crbug.com/1271215): Windows
-  # TODO(crbug.com/1426472): use_clang_coverage
-  # TODO(crbug.com/1427362): using_sanitizer
-  # TODO(crbug.com/1427364): target_cpu != "x86"
-  # There is no specific bug for !is_official_build or other platforms, since
-  # this is just a matter of rolling things out slowly and carefully and there
-  # may be no actual bugs there.
-  enable_rust = (is_linux || is_android) && !is_official_build &&
-                !using_sanitizer && target_cpu != "x86" &&
-                !use_clang_coverage && is_clang && build_with_chromium
+  enable_rust =
+      !is_mac && !is_ios && !is_win &&
+      (!is_official_build || is_linux || is_android) && build_with_chromium
 
   # As we incrementally enable Rust on mainstream builders, we want to enable
   # the toolchain (by switching 'enable_rust' to true) while still disabling
@@ -35,25 +29,18 @@ declare_args() {
   # all Rust features enabled.
   enable_all_rust_features = false
 
-  # Use the Rust toolchain built in-tree. See //tools/rust.
-  use_chromium_rust_toolchain = true
-
-  # Build libstd locally with GN and use that instead of the prebuilts, where
-  # applicable. If this is false the prebuilt libstd will always be used. If
-  # true, the local build is only used with the Chromium Rust toolchain and only
-  # on supported platforms and GN targets.
-  enable_local_libstd = true
-
-  # Chromium currently has a Rust toolchain for Android and Linux, but
-  # if you wish to experiment on more platforms you can use this
-  # argument to specify an alternative toolchain.
-  # This should be an absolute path to a directory
-  # containing a 'bin' directory and others. Commonly
+  # Chromium provides a Rust toolchain in //third_party/rust-toolchain when
+  # checkout_rust is True (which is being rolled out by default over time).
+  #
+  # To use a custom toolchain instead, specify an absolute path to the root of
+  # a Rust sysroot, which will have a 'bin' directory and others. Commonly
   # <home dir>/.rustup/toolchains/nightly-<something>-<something>
   rust_sysroot_absolute = ""
 
-  # If you're using an external Rust toolchain, set this to a Rust
-  # the output of rustc -V.
+  # If you're using a Rust toolchain as specified by rust_sysroot_absolute,
+  # set this to the output of `rustc -V`. Changing this string will cause all
+  # Rust targets to be rebuilt, which allows you to update your toolchain and
+  # not break incremental builds.
   rustc_version = ""
 
   # If you're using a Rust toolchain as specified by rust_sysroot_absolute,
@@ -77,23 +64,15 @@ declare_args() {
   # more work is done.
   use_goma_rust = false
 
-  # The host toolchain to use when you don't want sanitizers enabled. By default
-  # it is the regular toolchain, but when that toolchain has sanitizers, then
-  # this variable is changed to avoid them.
-  host_toolchain_no_sanitizers = host_toolchain
+  # Force-enable `--color=always` for rustc, even when it would be disabled for
+  # a platform. Mostly applicable to Windows, where new versions can handle ANSI
+  # escape sequences but it's not reliable in general.
+  force_rustc_color_output = false
 }
 
+# Use a separate declare_args so these variables' defaults can depend on the
+# ones above.
 declare_args() {
-  # Use a separate declare_args so these variables' defaults can depend on the
-  # ones above.
-
-  # When true, uses the locally-built std in all Rust targets.
-  #
-  # As an internal implementation detail this can be overridden on specific
-  # targets (e.g. to run build.rs scripts while building std), but this
-  # generally should not be done.
-  use_local_std_by_default = enable_local_libstd && use_chromium_rust_toolchain
-
   # Individual Rust components.
 
   # Conversions between Rust types and C++ types.
@@ -109,7 +88,7 @@ declare_args() {
   enable_rust_mojo = enable_all_rust_features
 
   # Support for the 'gnrt' Rust tool.
-  enable_rust_gnrt = enable_all_rust_features
+  enable_rust_gnrt = host_toolchain == current_toolchain
 
   # Rust gtest interop
   enable_rust_gtest_interop = enable_all_rust_features
@@ -118,36 +97,35 @@ declare_args() {
   enable_rust_boringssl = enable_all_rust_features
 }
 
-# Platform support for "official" toolchains (Android or Chromium)
-android_toolchain_supports_platform =
-    (!is_nacl &&
-     (is_android && (current_cpu == "arm" || current_cpu == "arm64" ||
-                     current_cpu == "x64" || current_cpu == "x86"))) ||
-    (is_linux && current_cpu == "x64")
+# Use the Rust toolchain built in-tree. When false, we use the prebuilt Rust
+# stdlibs that come with the specified custom toolchain.
+use_chromium_rust_toolchain = rust_sysroot_absolute == ""
+
+# Platform support for the Rust toolchain.
 chromium_toolchain_supports_platform = !is_nacl
 custom_toolchain_supports_platform = !is_nacl || rust_toolchain_supports_nacl
 
-toolchain_has_rust =
-    enable_rust &&
-    ((use_chromium_rust_toolchain && chromium_toolchain_supports_platform) ||
-     (!use_chromium_rust_toolchain && android_toolchain_supports_platform) ||
-     (rust_sysroot_absolute != "" && custom_toolchain_supports_platform))
+# Not all target triples (GN toolchains) are supported by the Rust compiler.
+# Define if we support the current GN toolchain.
+toolchain_has_rust = false
 
 # The rustc_revision is used to introduce a dependency on the toolchain version
 # (so e.g. rust targets are rebuilt, and the standard library is re-copied when
 # the toolchain changes). It is left empty for custom toolchains.
 rustc_revision = ""
-if (toolchain_has_rust) {
+
+if (enable_rust) {
   if (use_chromium_rust_toolchain) {
-    update_rust_args = [ "--print-package-version" ]
-    rustc_revision = exec_script("//tools/rust/update_rust.py",
-                                 update_rust_args,
-                                 "trim string")
-  } else if (rust_sysroot_absolute != "") {
-    rustc_revision = rustc_version
+    toolchain_has_rust = chromium_toolchain_supports_platform
+    if (toolchain_has_rust) {
+      update_rust_args = [ "--print-package-version" ]
+      rustc_revision = exec_script("//tools/rust/update_rust.py",
+                                   update_rust_args,
+                                   "trim string")
+    }
   } else {
-    # Android toolchain version.
-    rustc_revision = "rustc 1.64.0-dev (Android Rust Toolchain version 9099361)"
+    toolchain_has_rust = custom_toolchain_supports_platform
+    rustc_revision = rustc_version
   }
 }
 
@@ -163,22 +141,16 @@ build_rust_crash = toolchain_has_rust && enable_rust_crash
 # portability. In practice if an external toolchain was specified, it might
 # be an absolute path, but we'll do our best.
 if (enable_rust) {
-  if (rust_sysroot_absolute != "") {
-    rust_sysroot = get_path_info(rust_sysroot_absolute, "abspath")
-    use_unverified_rust_toolchain = true
-  } else if (use_chromium_rust_toolchain) {
+  if (use_chromium_rust_toolchain) {
     rust_sysroot = "//third_party/rust-toolchain"
-    use_unverified_rust_toolchain = false
   } else {
-    if (host_os != "linux") {
-      assert(false,
-             "Attempt to use Android Rust toolchain on an unsupported platform")
-    }
-
-    rust_sysroot = "//third_party/android_rust_toolchain/toolchain"
-    use_unverified_rust_toolchain = false
-    extra_sysroot_libs += [ "libunwind.a" ]
+    rust_sysroot = get_path_info(rust_sysroot_absolute, "abspath")
   }
+
+  # Prebuilt toolchains won't come with bindgen, so we unconditionally use the
+  # bindgen we ship with the Rust toolchain. This could be made configurable
+  # if folks want to supply a bindgen with their toolchain.
+  rust_bindgen_root = "//third_party/rust-toolchain"
 }
 
 # Figure out the Rust target triple (aka 'rust_abi_target')
@@ -194,13 +166,28 @@ if (enable_rust) {
 # other toolchains.
 rust_abi_target = ""
 if (is_linux || is_chromeos) {
-  cpu = current_cpu
-  if (cpu == "arm64") {
-    cpu = "aarch64"
-  } else if (cpu == "x64") {
-    cpu = "x86_64"
+  if (current_cpu == "arm64") {
+    rust_abi_target = "aarch64-unknown-linux-gnu"
+  } else if (current_cpu == "x86") {
+    rust_abi_target = "i686-unknown-linux-gnu"
+  } else if (current_cpu == "x64") {
+    rust_abi_target = "x86_64-unknown-linux-gnu"
+  } else if (current_cpu == "arm") {
+    if (arm_float_abi == "hard") {
+      float_suffix = "hf"
+    } else {
+      float_suffix = ""
+    }
+    if (arm_arch == "armv7-a" || arm_arch == "armv7") {
+      # No way to inform Rust about the -a suffix.
+      rust_abi_target = "armv7-unknown-linux-gnueabi" + float_suffix
+    } else {
+      rust_abi_target = "arm-unknown-linux-gnueabi" + float_suffix
+    }
+  } else {
+    # Best guess for other future platforms.
+    rust_abi_target = current_cpu + "-unknown-linux-gnu"
   }
-  rust_abi_target = cpu + "-unknown-linux-gnu"
 } else if (is_android) {
   import("//build/config/android/abi.gni")
   rust_abi_target = android_abi_target
@@ -219,7 +206,11 @@ if (is_linux || is_chromeos) {
   }
 } else if (is_ios) {
   if (current_cpu == "arm64") {
-    rust_abi_target = "aarch64-apple-ios"
+    if (target_environment == "simulator") {
+      rustc_target = "aarch64-apple-ios-sim"
+    } else {
+      rustc_target = "aarch64-apple-ios"
+    }
   } else if (current_cpu == "arm") {
     # There's also an armv7s-apple-ios, which targets a more recent ARMv7
     # generation CPU found in later iPhones. We'll go with the older one for
@@ -244,13 +235,23 @@ if (is_linux || is_chromeos) {
 } else if (is_win) {
   if (current_cpu == "arm64") {
     rust_abi_target = "aarch64-pc-windows-msvc"
-  } else if (current_cpu == "x86" || current_cpu == "x64") {
+  } else if (current_cpu == "x86") {
+    rust_abi_target = "i686-pc-windows-msvc"
+  } else if (current_cpu == "x64") {
     rust_abi_target = "x86_64-pc-windows-msvc"
   } else {
     assert(false, "Architecture not supported")
   }
 }
 
+
+if (current_cpu == "x86") {
+    rustc_target = "i686-pc-windows-msvc"
+  } else if (current_cpu == "x64") {
+    rustc_target = "x86_64-pc-windows-msvc"
+  } else if (current_cpu == "arm64") {
+    rustc_target = "aarch64-pc-windows-msvc"
+  }
 assert(!toolchain_has_rust || rust_abi_target != "")
 
 # This variable is passed to the Rust libstd build.
@@ -277,20 +278,6 @@ if (current_cpu == "x86") {
 
 assert(!toolchain_has_rust || rust_target_arch != "")
 
-# Must use Chromium Rust toolchain to get precisely matching LLVM versions
-# in order to enable LTO. Some say that LTO probably works if LLVM is "close
-# enough", but we don't want to take that risk.
-assert(!use_thin_lto || !enable_rust || use_chromium_rust_toolchain ||
-           use_unverified_rust_toolchain,
-       "Must use Chromium Rust toolchain for LTO")
-
-# Determine whether the local libstd can and should be built.
-local_libstd_supported = enable_local_libstd && use_chromium_rust_toolchain
-
-# Determine whether the prebuilt libstd can be used
-prebuilt_libstd_supported = !use_chromium_rust_toolchain ||
-                            (target_os == "linux" && target_cpu == "x64")
-
 # Arguments for Rust invocation.
 # This is common between gcc/clang, Mac and Windows toolchains so specify once,
 # here. This is not the complete command-line: toolchains should add -o
@@ -298,13 +285,20 @@ prebuilt_libstd_supported = !use_chromium_rust_toolchain ||
 rustc_common_args = "--crate-name {{crate_name}} {{source}} --crate-type {{crate_type}} {{rustflags}}"
 
 # Rust procedural macros are shared objects loaded into a prebuilt host rustc
-# binary. To build them, we obviously need to build for the host. Not only that,
-# but because the host rustc is prebuilt, it lacks the machinery to be able to
-# load shared objects built using sanitizers (ASAN etc.) For that reason, we need
-# to use a host toolchain that lacks sanitizers. This is only strictly necessary
-# for procedural macros, but we may also choose to build standalone Rust host
-# executable tools using the same toolchain, as they're likely to depend upon
-# similar dependencies (syn, quote etc.) and it saves a little build time.
-if (using_sanitizer || toolchain_disables_sanitizers) {
-  host_toolchain_no_sanitizers = "${host_toolchain}_no_sanitizers"
+# binary. To build them, we obviously need to build for the host. Not only
+# that, but because the host rustc is prebuilt, it lacks the machinery to be
+# able to load shared objects built using sanitizers (ASAN etc.). For that
+# reason, we need to use a host toolchain that lacks sanitizers. Additionally,
+# proc macros should use panic=unwind, which means they need a stdlib that is
+# compiled the same way, as is the stdlib that we ship with the compiler.
+if (toolchain_for_rust_host_build_tools) {
+  rust_macro_toolchain = current_toolchain
+} else {
+  rust_macro_toolchain = "${host_toolchain}_for_rust_host_build_tools"
 }
+
+# When this is true, a prebuilt Rust stdlib will be used. This has implications
+# such as that the panic strategy (unwind, abort) must match how the stdlib is
+# compiled, which is typically as unwind.
+rust_prebuilt_stdlib =
+    !use_chromium_rust_toolchain || toolchain_for_rust_host_build_tools
